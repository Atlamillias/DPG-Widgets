"""Contains objects used in defining, caching, or managing an item's internal configuration."""
import functools
from inspect import signature
from typing import Callable, Any, Union, TypeVar
from dearpygui._dearpygui import (
    # getters
    get_item_configuration as _get_item_configuration,
    get_item_info as _get_item_info,
    get_item_state as _get_item_state,
    get_value as _get_value,
    # setters
    configure_item as _configure_item,
    set_value as _set_value,

)

CONFIGURATION = "configuration"
INFORMATION   = "information"
STATE         = "state"



#########################################
#### `ItemAttribute` getters/setters ####
#########################################

# NOTE: The following have been wrapped to mirror the signature of `setattr`.
def configure_item(__o, attr, value):
    _configure_item(__o._tag, **{attr: value})

def set_value(__o, attr, value):
    _set_value(__o._tag, value)

# NOTE: The following have been wrapped to mirror the signature of `getattr`.
def get_item_configuration(__o: object, __name: str):
    return _get_item_configuration(__o._tag)[__name]

def get_item_info(__o: object, __name: str):
    return _get_item_info(__o._tag)[__name]

def get_item_state(__o: object, __name: str):
    return _get_item_state(__o._tag)[__name]

def get_value(__o: object, __name: str = None):
    return _get_value(__o._tag)

def get_unmanagable(__o: object, __name: str):
    # "Unmanaged" attributes cannot be gotten or set from DPG after item
    # creation. The values are saved in the instance dictionary as private
    # attributes.
    return getattr(__o, f"_{__name}")




############################################
#### Low-level Configuration Management ####
############################################
class ItemAttribute:
    """Descriptor object for accessing DearPyGui item attributes. Functionally similar
    to the `property` built-in, but cannot be used as a decorator.

    Attributes:
        * category: str
        * getter: Callable | None
        * setter: Callable | None
        * target: str
        * doc: str
    """
    CONFIGURATION = CONFIGURATION
    INFORMATION   = INFORMATION
    STATE         = STATE

    category_cmd_map = {
        CONFIGURATION: (get_item_configuration, configure_item),
        INFORMATION  : (get_item_info         , None          ),
        STATE        : (get_item_state        , None          ),
    }
    next_class_item_attrs = {
        CONFIGURATION: set(),
        INFORMATION  : set(),
        STATE        : set(),
    }

    def __init__(
        self,
        category: str                        = "configuration",
        getter  : Union[str, Callable, None] = ...,
        setter  : Union[str, Callable, None] = ...,
        target  : str                        = None,
        doc     : str                        = None
    ):
        """Args:
            * category (str): Value should be `configuration`, `information` or `state`.
            * getter (str | Callable | None): Object that is called to retrieve the 
            attribute value. A call to the object must be able be resolved using the same
            arguments required for `getattr`, and must accept those arguments.
            * setter (str | Callable | None): Object that is called to set the attribute
            to a passed value. A call to the object must be able to be resolved using the same
            arguments required for `setattr`, and must accept those arguments.
        """
        self.category = category
        self.fget     = getter
        self.fset     = setter
        self.target   = target

        if doc is None and getter is not None:
            doc = getter.__doc__
        self.__doc__ = doc
        self._name = ''

    def __set_name__(self, __type: type, name: str):
        self._name  = name
        self._item  = __type
        self.target = name if self.target is None else self.target
        
        try:
            # Setting default getter/setter based on category if one wasn't included.
            category_defaults = self.category_cmd_map[self.category]
        except KeyError:
            raise ValueError(f"`category` must be 'configuration', 'state', or 'information' (got {self.category!r}).")

        # NOTE: Ellipsis is used to differentiate `not included` from `None`. Setting a getter
        #       or setter to `None` is meaningful. If the value is `...`, it will use category
        #       defaults.
        for idx, attr in enumerate(("fget", "fset")):
            value = getattr(self, attr)
            if value == ...:
                setattr(self, attr, category_defaults[idx])
            elif isinstance(value, str):
                try:
                    # NOTE: If a string is used for fget/fset it must be defined in this module.
                    setattr(self, attr, globals()[value])
                except KeyError:
                    raise AttributeError(f"{attr!r} value {value!r} is not defined in {__name__!r}.")
        ItemAttribute.next_class_item_attrs[self.category].add(name)

    def __get__(self, instance: object, __type: type):
        # NOTE: A `try`/`except` block is used instead of a conditional `if` check. This
        #       adds overhead to startup and imports, but normal attribute access at runtime
        #       is faster.  
        try:
            return self.fget(instance, self.target)
        except AttributeError as e:
            # Raised from `instance` not having the `_tag` attribute when `instance` is `None`.
            if instance is None:
                return self
            raise e

    def __set__(self, instance: object, value):
        # NOTE: `try`/`except` blocks are used instead of conditional `if` checks. This
        #       adds overhead to startup and imports, but normal attribute access at runtime
        #       is faster.  
        try:
            self.fset(instance, self.target, value)
        except TypeError as e:
            if self.fset is None:
                raise AttributeError(f"The {self._name!r} attribute is read-only and cannot be set.")
            raise e


def item_attribute(cls_attribute: Union[Callable, str] = None, *, category: str):
    """Wrapper function for registering class-defined attributes that are to be managed as
    item attributes (an alternative to using the `ItemAttribute` descriptor). Useful if
    the behavior of the `ItemAttribute` descriptor isn't suitable, and a more simple/complex
    implementation is required for proper attribute access. If this is used as a method
    decorator, this must be the inner decorator.

    Args:
        * cls_attribute (Callable | str): The attribute to register. If it is a method,
        `cls_attribute.__name__` is registered.
        * category (str, keyword-only): Category to register the attribute under.
        Must be "configuration", "information", or "state".

    Examples:
    >>> class PseudoItem:
    ...     x = item_attribute("x", category="configuration")
    None
    >>> class PseudoItem:
    ...     @property
    ...     @item_attribute(category="configuration")
    ...     def config_property(self):
    ...         ...
    None
    """

    @functools.wraps(cls_attribute)
    def register(obj):
        # Register the attribute by category.
        if isinstance(obj, str):
            name = obj
        elif callable(obj):
            # `obj` should be a method
            name = obj.__name__
        else:
            raise ValueError(f"`obj` must be a string or callable method (got {type(obj)!r}).")
            
        try:
            ItemAttribute.next_class_item_attrs[category].add(name)
        except KeyError:
            raise ValueError(f"`category` must be 'configuration', 'state', or 'information' (got {category!r}).")
        return obj
    
    if cls_attribute:
        return register(cls_attribute)
    return register





class ItemTemplate:
    _target_params = ()
    _configuration = ()

    def __init__(self, target_item, **kwargs):
        """A configuration container for Item objects.

        Args:
            * target_item (Item): The item you wish to instantiate using this
            object's configuration.
        """
        self._target_item = target_item
        self._target_params = tuple([*target_item._init_params])
        self._configuration = {}
        self.configure(**kwargs)

    def __setattr__(self, attr, value):
        if attr in self._target_params:
            self._configuration[attr] = value
            return None
        elif attr.startswith("_"):  # allow private attributes
            return object.__setattr__(self, attr, value)
        raise AttributeError(
            f"{self._target_item!r} does not accept this parameter.")

    def __getattr__(self, attr):
        if attr in self._configuration:
            return self._configuration[attr]
        elif attr in self._target_params:
            return None
        raise AttributeError(f"{type(self)!r} has no attribute {attr!r}.")

    def create(self):
        """Return an instance from the target item using this object's configuration.
        """
        return self._target_item(**self._configuration)

    def parameters(self) -> tuple:
        """Return a tuple containing the accepted parameters for the
        target constructor.
        """
        return self._target_params

    def configuration(self) -> dict:
        return self._configuration

    def configure(self, **config) -> None:
        _setattr = self.__setattr__
        [_setattr(optn, value) for optn, value in config.items()]

    alpha_bar: bool = ...
    alpha_preview: int = ...
    angle: float = ...
    anti_aliased: bool = ...
    arrow: bool = ...
    attr_1: Union[int, str] = ...
    attr_2: Union[int, str] = ...
    attribute_type: int = ...
    autosize: bool = ...
    autosize_x: bool = ...
    autosize_y: bool = ...
    axis: int = ...
    background_color: Union[list[float], tuple[float, ...]] = ...
    bar_scale: float = ...
    bear_color: Union[list[int], tuple[int, ...]] = ...
    before: Union[int, str] = ...
    bins: int = ...
    border: bool = ...
    border_color: Union[list[float], tuple[float, ...]] = ...
    borders_innerH: bool = ...
    borders_innerV: bool = ...
    borders_outerH: bool = ...
    borders_outerV: bool = ...
    bounds_max: Union[list[float], tuple[float, ...]] = ...
    bounds_min: Union[list[float], tuple[float, ...]] = ...
    box_select_button: int = ...
    box_select_cancel_button: int = ...
    box_select_mod: int = ...
    bull_color: Union[list[int], tuple[int, ...]] = ...
    bullet: bool = ...
    button: int = ...
    callback: Callable = ...
    category: int = ...
    center: Union[list[float], tuple[float, ...]] = ...
    chars: Union[list[int], tuple[int, ...]] = ...
    check: bool = ...
    circle_count: int = ...
    clamped: bool = ...
    clipper: bool = ...
    closable: bool = ...
    closed: bool = ...
    closes: Union[list[float], tuple[float, ...]] = ...
    collapsed: bool = ...
    color: Union[list[int], tuple[int, ...]] = ...
    color_bottom_left: Union[list[int], tuple[int, ...]] = ...
    color_bottom_right: Union[list[int], tuple[int, ...]] = ...
    color_upper_left: Union[list[int], tuple[int, ...]] = ...
    color_upper_right: Union[list[int], tuple[int, ...]] = ...
    colormap: Union[int, str] = ...
    colors: list[list[int]] = ...
    cols: int = ...
    column_major: bool = ...
    column_ratios: Union[list[float], tuple[float, ...]] = ...
    columns: int = ...
    context_menu_button: int = ...
    context_menu_in_body: bool = ...
    contribute_to_bounds: bool = ...
    count: int = ...
    crosshairs: bool = ...
    cumlative: bool = ...
    custom_text: str = ...
    dates: Union[list[float], tuple[float, ...]] = ...
    decimal: bool = ...
    default_filename: str = ...
    default_hide: bool = ...
    default_open: bool = ...
    default_path: str = ...
    default_sort: bool = ...
    delay_search: bool = ...
    delink_callback: Callable = ...
    density: bool = ...
    direction: int = ...
    directory_selector: bool = ...
    display_hex: bool = ...
    display_hsv: bool = ...
    display_mode: int = ...
    display_rgb: bool = ...
    display_type: int = ...
    drag_callback: Callable = ...
    drag_data: Any = ...
    draggable: bool = ...
    drop_callback: Callable = ...
    drop_data: Any = ...
    enabled: bool = ...
    enabled_state: bool = ...
    equal_aspects: bool = ...
    extension: str = ...
    file: str = ...
    file_count: int = ...
    fill: Union[list[int], tuple[int, ...]] = ...
    filter_key: str = ...
    first_char: int = ...
    fit_button: int = ...
    format: str = ...
    frame_padding: int = ...
    freeze_columns: int = ...
    freeze_rows: int = ...
    front: bool = ...
    header_row: bool = ...
    height: int = ...
    height_mode: int = ...
    hexadecimal: bool = ...
    hideable: bool = ...
    highs: Union[list[float], tuple[float, ...]] = ...
    hint: str = ...
    histogram: bool = ...
    horizontal: bool = ...
    horizontal_mod: int = ...
    horizontal_scrollbar: bool = ...
    horizontal_spacing: float = ...
    hour24: bool = ...
    indent: int = ...
    indent_disable: bool = ...
    indent_enable: bool = ...
    init_width_or_weight: float = ...
    inner_width: int = ...
    input_mode: int = ...
    invert: bool = ...
    item: Union[int, str] = ...
    item_type: int = ...
    items: Union[list[str], tuple[str, ...]] = ...
    key: int = ...
    kwargs: dict = ...
    label: str = ...
    labels: Union[list[str], tuple[str, ...]] = ...
    last_char: int = ...
    leading: bool = ...
    leaf: bool = ...
    level: int = ...
    link_all_x: bool = ...
    link_all_y: bool = ...
    link_columns: bool = ...
    link_rows: bool = ...
    location: int = ...
    lock_max: bool = ...
    lock_min: bool = ...
    log_scale: bool = ...
    lows: Union[list[float], tuple[float, ...]] = ...
    max_clamped: bool = ...
    max_range: float = ...
    max_scale: float = ...
    max_size: Union[list[int], tuple[int, ...]] = ...
    max_value: int = ...
    max_x: float = ...
    max_y: float = ...
    max_z: float = ...
    menubar: bool = ...
    min_clamped: bool = ...
    min_range: float = ...
    min_scale: float = ...
    min_size: Union[list[int], tuple[int, ...]] = ...
    min_value: int = ...
    min_x: float = ...
    min_y: float = ...
    min_z: float = ...
    modal: bool = ...
    multicolor: bool = ...
    multiline: bool = ...
    negative: Union[list[float], tuple[float, ...]] = ...
    no_align: bool = ...
    no_alpha: bool = ...
    no_arrow_button: bool = ...
    no_background: bool = ...
    no_border: bool = ...
    no_box_select: bool = ...
    no_bring_to_front_on_focus: bool = ...
    no_child: bool = ...
    no_clip: bool = ...
    no_close: bool = ...
    no_collapse: bool = ...
    no_drag_drop: bool = ...
    no_focus_on_appearing: bool = ...
    no_gridlines: bool = ...
    no_header_width: bool = ...
    no_hide: bool = ...
    no_highlight: bool = ...
    no_host_extendX: bool = ...
    no_host_extendY: bool = ...
    no_input: bool = ...
    no_inputs: bool = ...
    no_keep_columns_visible: bool = ...
    no_label: bool = ...
    no_menus: bool = ...
    no_mouse_pos: bool = ...
    no_move: bool = ...
    no_options: bool = ...
    no_pad_innerX: bool = ...
    no_pad_outerX: bool = ...
    no_picker: bool = ...
    no_preview: bool = ...
    no_reorder: bool = ...
    no_resize: bool = ...
    no_saved_settings: bool = ...
    no_scrollbar: bool = ...
    no_side_preview: bool = ...
    no_small_preview: bool = ...
    no_sort: bool = ...
    no_sort_ascending: bool = ...
    no_sort_descending: bool = ...
    no_spaces: bool = ...
    no_tick_labels: bool = ...
    no_tick_marks: bool = ...
    no_title: bool = ...
    no_title_bar: bool = ...
    no_tooltip: bool = ...
    normalize: bool = ...
    num_items: int = ...
    offset: Union[list[float], tuple[float, ...]] = ...
    on_close: Callable = ...
    on_enter: bool = ...
    open_on_arrow: bool = ...
    open_on_double_click: bool = ...
    opens: Union[list[float], tuple[float, ...]] = ...
    order_mode: bool = ...
    outliers: bool = ...
    outside: bool = ...
    overlay: str = ...
    p1: Union[list[float], tuple[float, ...]] = ...
    p2: Union[list[float], tuple[float, ...]] = ...
    p3: Union[list[float], tuple[float, ...]] = ...
    p4: Union[list[float], tuple[float, ...]] = ...
    pad_outerX: bool = ...
    pan_button: int = ...
    pan_mod: int = ...
    parent: Union[int, str] = ...
    password: bool = ...
    payload_type: str = ...
    picker_mode: int = ...
    pmax: Union[list[float], tuple[float, ...]] = ...
    pmin: Union[list[float], tuple[float, ...]] = ...
    points: list[list[float]] = ...
    policy: int = ...
    popup: bool = ...
    popup_align_left: bool = ...
    pos: Union[list[float], tuple[float, ...]] = ...
    positive: Union[list[float], tuple[float, ...]] = ...
    precise_widths: bool = ...
    prefer_sort_ascending: bool = ...
    prefer_sort_descending: bool = ...
    qualitative: bool = ...
    query: bool = ...
    query_button: int = ...
    query_mod: int = ...
    query_toggle_mod: int = ...
    radius: float = ...
    readonly: bool = ...
    reorderable: bool = ...
    resizable: bool = ...
    rounding: float = ...
    row_background: bool = ...
    row_ratios: Union[list[float], tuple[float, ...]] = ...
    rows: int = ...
    scale: float = ...
    scale_max: float = ...
    scale_min: float = ...
    scientific: bool = ...
    scrollX: bool = ...
    scrollY: bool = ...
    secondary_color: Union[list[int], tuple[int, ...]] = ...
    segments: int = ...
    selectable: bool = ...
    shape: int = ...
    shortcut: str = ...
    show: bool = ...
    show_label: bool = ...
    size: float = ...
    small: bool = ...
    sort_multi: bool = ...
    sort_tristate: bool = ...
    sortable: bool = ...
    source: Union[int, str] = ...
    span_columns: bool = ...
    speed: float = ...
    step: int = ...
    step_fast: int = ...
    style: int = ...
    tab_input: bool = ...
    tag: Union[int, str] = ...
    target: int = ...
    text: str = ...
    texture_tag: Union[int, str] = ...
    thickness: float = ...
    threshold: float = ...
    time: bool = ...
    tint_color: Union[list[int], tuple[int, ...]] = ...
    tooltip: bool = ...
    track_offset: float = ...
    tracked: bool = ...
    trailing: bool = ...
    uppercase: bool = ...
    use_internal_label: bool = ...
    user_data: Any = ...
    uv_max: Union[list[float], tuple[float, ...]] = ...
    uv_min: Union[list[float], tuple[float, ...]] = ...
    value: Any = ...
    values: Union[list[float], tuple[float, ...]] = ...
    vertical: bool = ...
    vertical_mod: int = ...
    weight: int = ...
    width: int = ...
    width_fixed: bool = ...
    width_stretch: bool = ...
    wrap: int = ...
    x: Union[list[float], tuple[float, ...]] = ...
    x_offset: int = ...
    xbins: int = ...
    xmax_range: float = ...
    xmin_range: float = ...
    xoffset: float = ...
    y: float = ...
    y1: Union[list[float], tuple[float, ...]] = ...
    y2: Any = ...
    y_offset: int = ...
    ybins: int = ...
    ymax_range: float = ...
    ymin_range: float = ...
