"""Contains objects used in defining, caching, or managing an item's internal configuration."""
import functools
from inspect import signature
from typing import Callable, Any, Union
from dearpygui._dearpygui import (
    configure_item,
    get_item_configuration,
    get_item_info,
    get_item_state,
    set_value,
    get_value as _get_value,
)



_CATEGORY = (
    "configuration",
    "information",
    "state",
)

_categorized_new_cls_props = {cat:set() for cat in _CATEGORY}


def common_getter(func):
    @functools.wraps(func)
    def bound_dpg_cmd(instance: object, attr: str, private_attr: str):
        try:
            return func(instance._tag)[attr]
        except KeyError:
            return getattr(instance, private_attr)

    return bound_dpg_cmd


def get_value(instance, *args):
    return _get_value(instance._tag)


def get_unmanagable(instance, attr, private_attr):
    return getattr(instance, private_attr)


get_item_configuration = common_getter(get_item_configuration)
get_item_info          = common_getter(get_item_info)
get_item_state         = common_getter(get_item_state)


def item_attribute(func=None, *, category: str = "configuration"):
    """A decorator to be used on properties (`property`) that manage
    an (internal) item attribute. If the name of the defined property
    differs from the actual name of the attribute, `target_attr` must
    be included and must be the actual name of the target attribute.
    The `property` decorator must be the outer decorator.

    This can be used instead of the `ItemAttribute` descriptor if more
    customization is needed than what the default `ItemAttribute`
    implementation can offer.

    Args:
        * function ([type], optional): The function object to decorate.
        Defaults to None.
        * target_attr (str, optional): The key/name of the internal item
        attribute. Defaults to None (`function.__name__`).
    """
    @functools.wraps(func)
    def wrapper(obj):
        # Register the attribute by category.
        name = obj.__name__
        try:
            _categorized_new_cls_props[category].add(name)
        except KeyError:
            raise ValueError("Incorrect value for `category`; must be 'configuration', 'state', or 'information'.")
        return obj

    if not func:
        return wrapper
    return wrapper(func)


class ItemAttribute:
    def __init__(
        self,
        category: str = "configuration",
        getter: Union[str, Callable, None] = ...,
        setter: Union[str, Callable, None] = ...,
        target: str = None,
        doc: str = None
    ):
        """DearPyGui configuration handler. Functionally similar to the `property`
        built-in, but specific to dearpygui keyword attributes. Cannot be used
        as a decorator. 
        """
        self.category = category
        self.fget = getter
        self.fset = setter
        self.target = target

        if doc is None and getter is not None:
            doc = getter.__doc__
        self.__doc__ = doc
        self._name = ''

    def __set_name__(self, __type: type, name: str):
        self._name = name
        self._private_name = f"_{name}"
        self._item = __type
        self.target = name if self.target is None else self.target

        # Setting default getter/setter based on category if one wasn't included.
        # NOTE: Default ellipsis is used to differentiate `not included`
        # from `None`. Setting a getter or setter to `None` is meaningful.
        # If the value is `...` it will use the default configuration.
        try:
            category_defaults = self.category_cmd_map[self.category]
        except KeyError:
            raise ValueError("Incorrect value for `category`; must be 'configuration', 'state', or 'information'.")
        for idx, attr in enumerate(("fget", "fset")):
            value = getattr(self, attr)
            if value == ...:
                setattr(self, attr, category_defaults[idx])
            elif isinstance(value, str):
                try:
                    setattr(self, attr, self.cmd_attr_map[value])
                except KeyError:
                    raise AttributeError(f"{__name__!r} has no attribute {value!r}.")
        _categorized_new_cls_props[self.category].add(name)

    def __get__(self, instance: object, __type: type):
        try:
            return self.fget(instance, self.target, self._private_name)
        # raised from `common_getter` trying to get `tag` from `instance` i.e.
        # `None._tag`.
        except AttributeError:
            return self

    def __set__(self, instance: object, value):
        if self.fset is None:
            raise AttributeError(f"The {self._name!r} attribute is read-only and cannot be set.")
        self.fset(instance._tag, **{self.target: value})

    category_cmd_map = {
        "configuration": (get_item_configuration, configure_item),
        "information": (get_item_info, None),
        "state": (get_item_state, None),
    }

    cmd_attr_map = {
        "get_item_configuration": get_item_configuration,
        "get_item_info": get_item_info,
        "get_item_state": get_item_state,
        "configure_item": configure_item,
        "get_value": get_value,
        "set_value": set_value,
        "get_unmanagable": get_unmanagable
    }


class ItemAttributeCache:
    """Updates attribute dictionaries for `Item` class derivatives, ensuring
    that the new subclass has all configuration, information, and state attributes/keys
    from their ancestor(s), along with any new additions of its own. Mixin classes
    can (should) inherit from this as well if they define new attributes with the
    intention of passing them onto descendants as internally managed attributes.

    Glossary:
        * config_attrs: A collection of item attributes that can be used as an
        argument for an item's creation, and can still be configured afterwards.
        * inform_attrs: A collection of item attributes that can potentially
        be used as an argument for an item's creation, but is generally read-only
        afterwards.
        * states_attrs: A collection of item attributes that are read-only. They
        are not used as item-creation arguments and are not configurable.
        * attr_aliases: A mapping of an item's defined class or instance attributes
        pointing to the name of the internal item attribute that they actually manage.
    """
    def __init_subclass__(cls):
        super().__init_subclass__()
        config_attrs = _categorized_new_cls_props["configuration"]
        inform_attrs = _categorized_new_cls_props["information"]
        states_attrs = _categorized_new_cls_props["state"]
        init_params  = set()
        # Iterate from oldest to newest object; excluding `object`
        # and `ItemAttributeCache` (2 oldest) and `cls` (newest).
        for derived_from in cls.mro()[-3:0:-1]:
            config_attrs |= derived_from.__dict__.get("_config_attrs", set())
            inform_attrs |= derived_from.__dict__.get("_inform_attrs", set())
            states_attrs |= derived_from.__dict__.get("_states_attrs", set())
            init_params  |= derived_from.__dict__.get("_init_params" , set())
        cls._config_attrs = cls.__dict__.get("_config_attrs", set()) | config_attrs
        cls._inform_attrs = cls.__dict__.get("_inform_attrs", set()) | inform_attrs
        cls._states_attrs = cls.__dict__.get("_states_attrs", set()) | states_attrs
        cls._init_params = {*signature(cls).parameters} | init_params
        # Reset the global variable for the next subclass.
        [_set.clear() for _set in _categorized_new_cls_props.values()]
        # Storing unmanagable attribute names.
        unmanagable_attrs = set()
        for attr_name in {*cls._config_attrs, *cls._inform_attrs}:
            attr = getattr(cls, attr_name)
            if hasattr(attr, "__get__") and getattr(attr, "fget") == get_unmanagable:
                unmanagable_attrs.add(attr_name)
        cls._unmanaged_attrs = unmanagable_attrs


class ConfigContainer:
    _target_params = ()
    _configuration = ()

    def __init__(self, target_item, **kwargs):
        """A configuration container for Item objects.

        Args:
            * target_item (Item): The item you wish to instantiate using this
            object's configuration.
        """
        self._target_item = target_item
        self._target_params = tuple([*target_item._init_params])
        self._configuration = {}
        self.configure(**kwargs)

    def __setattr__(self, attr, value):
        if attr in self._target_params:
            self._configuration[attr] = value
            return None
        elif attr.startswith("_"):  # allow private attributes
            return object.__setattr__(self, attr, value)
        raise AttributeError(
            f"{self._target_item!r} does not accept this parameter.")

    def __getattr__(self, attr):
        if attr in self._configuration:
            return self._configuration[attr]
        elif attr in self._target_params:
            return None
        raise AttributeError(f"{type(self)!r} has no attribute {attr!r}.")

    def create(self):
        """Return an instance from the target item using this object's configuration.
        """
        return self._target_item(**self._configuration)

    def parameters(self) -> tuple:
        """Return a tuple containing the accepted parameters for the
        target constructor.
        """
        return self._target_params

    def configuration(self) -> dict:
        return self._configuration

    def configure(self, **config) -> None:
        _setattr = self.__setattr__
        [_setattr(optn, value) for optn, value in config.items()]

    alpha_bar: bool = ...
    alpha_preview: int = ...
    angle: float = ...
    anti_aliased: bool = ...
    arrow: bool = ...
    attr_1: Union[int, str] = ...
    attr_2: Union[int, str] = ...
    attribute_type: int = ...
    autosize: bool = ...
    autosize_x: bool = ...
    autosize_y: bool = ...
    axis: int = ...
    background_color: Union[list[float], tuple[float, ...]] = ...
    bar_scale: float = ...
    bear_color: Union[list[int], tuple[int, ...]] = ...
    before: Union[int, str] = ...
    bins: int = ...
    border: bool = ...
    border_color: Union[list[float], tuple[float, ...]] = ...
    borders_innerH: bool = ...
    borders_innerV: bool = ...
    borders_outerH: bool = ...
    borders_outerV: bool = ...
    bounds_max: Union[list[float], tuple[float, ...]] = ...
    bounds_min: Union[list[float], tuple[float, ...]] = ...
    box_select_button: int = ...
    box_select_cancel_button: int = ...
    box_select_mod: int = ...
    bull_color: Union[list[int], tuple[int, ...]] = ...
    bullet: bool = ...
    button: int = ...
    callback: Callable = ...
    category: int = ...
    center: Union[list[float], tuple[float, ...]] = ...
    chars: Union[list[int], tuple[int, ...]] = ...
    check: bool = ...
    circle_count: int = ...
    clamped: bool = ...
    clipper: bool = ...
    closable: bool = ...
    closed: bool = ...
    closes: Union[list[float], tuple[float, ...]] = ...
    collapsed: bool = ...
    color: Union[list[int], tuple[int, ...]] = ...
    color_bottom_left: Union[list[int], tuple[int, ...]] = ...
    color_bottom_right: Union[list[int], tuple[int, ...]] = ...
    color_upper_left: Union[list[int], tuple[int, ...]] = ...
    color_upper_right: Union[list[int], tuple[int, ...]] = ...
    colormap: Union[int, str] = ...
    colors: list[list[int]] = ...
    cols: int = ...
    column_major: bool = ...
    column_ratios: Union[list[float], tuple[float, ...]] = ...
    columns: int = ...
    context_menu_button: int = ...
    context_menu_in_body: bool = ...
    contribute_to_bounds: bool = ...
    count: int = ...
    crosshairs: bool = ...
    cumlative: bool = ...
    custom_text: str = ...
    dates: Union[list[float], tuple[float, ...]] = ...
    decimal: bool = ...
    default_filename: str = ...
    default_hide: bool = ...
    default_open: bool = ...
    default_path: str = ...
    default_sort: bool = ...
    delay_search: bool = ...
    delink_callback: Callable = ...
    density: bool = ...
    direction: int = ...
    directory_selector: bool = ...
    display_hex: bool = ...
    display_hsv: bool = ...
    display_mode: int = ...
    display_rgb: bool = ...
    display_type: int = ...
    drag_callback: Callable = ...
    drag_data: Any = ...
    draggable: bool = ...
    drop_callback: Callable = ...
    drop_data: Any = ...
    enabled: bool = ...
    enabled_state: bool = ...
    equal_aspects: bool = ...
    extension: str = ...
    file: str = ...
    file_count: int = ...
    fill: Union[list[int], tuple[int, ...]] = ...
    filter_key: str = ...
    first_char: int = ...
    fit_button: int = ...
    format: str = ...
    frame_padding: int = ...
    freeze_columns: int = ...
    freeze_rows: int = ...
    front: bool = ...
    header_row: bool = ...
    height: int = ...
    height_mode: int = ...
    hexadecimal: bool = ...
    hideable: bool = ...
    highs: Union[list[float], tuple[float, ...]] = ...
    hint: str = ...
    histogram: bool = ...
    horizontal: bool = ...
    horizontal_mod: int = ...
    horizontal_scrollbar: bool = ...
    horizontal_spacing: float = ...
    hour24: bool = ...
    indent: int = ...
    indent_disable: bool = ...
    indent_enable: bool = ...
    init_width_or_weight: float = ...
    inner_width: int = ...
    input_mode: int = ...
    invert: bool = ...
    item: Union[int, str] = ...
    item_type: int = ...
    items: Union[list[str], tuple[str, ...]] = ...
    key: int = ...
    kwargs: dict = ...
    label: str = ...
    labels: Union[list[str], tuple[str, ...]] = ...
    last_char: int = ...
    leading: bool = ...
    leaf: bool = ...
    level: int = ...
    link_all_x: bool = ...
    link_all_y: bool = ...
    link_columns: bool = ...
    link_rows: bool = ...
    location: int = ...
    lock_max: bool = ...
    lock_min: bool = ...
    log_scale: bool = ...
    lows: Union[list[float], tuple[float, ...]] = ...
    max_clamped: bool = ...
    max_range: float = ...
    max_scale: float = ...
    max_size: Union[list[int], tuple[int, ...]] = ...
    max_value: int = ...
    max_x: float = ...
    max_y: float = ...
    max_z: float = ...
    menubar: bool = ...
    min_clamped: bool = ...
    min_range: float = ...
    min_scale: float = ...
    min_size: Union[list[int], tuple[int, ...]] = ...
    min_value: int = ...
    min_x: float = ...
    min_y: float = ...
    min_z: float = ...
    modal: bool = ...
    multicolor: bool = ...
    multiline: bool = ...
    negative: Union[list[float], tuple[float, ...]] = ...
    no_align: bool = ...
    no_alpha: bool = ...
    no_arrow_button: bool = ...
    no_background: bool = ...
    no_border: bool = ...
    no_box_select: bool = ...
    no_bring_to_front_on_focus: bool = ...
    no_child: bool = ...
    no_clip: bool = ...
    no_close: bool = ...
    no_collapse: bool = ...
    no_drag_drop: bool = ...
    no_focus_on_appearing: bool = ...
    no_gridlines: bool = ...
    no_header_width: bool = ...
    no_hide: bool = ...
    no_highlight: bool = ...
    no_host_extendX: bool = ...
    no_host_extendY: bool = ...
    no_input: bool = ...
    no_inputs: bool = ...
    no_keep_columns_visible: bool = ...
    no_label: bool = ...
    no_menus: bool = ...
    no_mouse_pos: bool = ...
    no_move: bool = ...
    no_options: bool = ...
    no_pad_innerX: bool = ...
    no_pad_outerX: bool = ...
    no_picker: bool = ...
    no_preview: bool = ...
    no_reorder: bool = ...
    no_resize: bool = ...
    no_saved_settings: bool = ...
    no_scrollbar: bool = ...
    no_side_preview: bool = ...
    no_small_preview: bool = ...
    no_sort: bool = ...
    no_sort_ascending: bool = ...
    no_sort_descending: bool = ...
    no_spaces: bool = ...
    no_tick_labels: bool = ...
    no_tick_marks: bool = ...
    no_title: bool = ...
    no_title_bar: bool = ...
    no_tooltip: bool = ...
    normalize: bool = ...
    num_items: int = ...
    offset: Union[list[float], tuple[float, ...]] = ...
    on_close: Callable = ...
    on_enter: bool = ...
    open_on_arrow: bool = ...
    open_on_double_click: bool = ...
    opens: Union[list[float], tuple[float, ...]] = ...
    order_mode: bool = ...
    outliers: bool = ...
    outside: bool = ...
    overlay: str = ...
    p1: Union[list[float], tuple[float, ...]] = ...
    p2: Union[list[float], tuple[float, ...]] = ...
    p3: Union[list[float], tuple[float, ...]] = ...
    p4: Union[list[float], tuple[float, ...]] = ...
    pad_outerX: bool = ...
    pan_button: int = ...
    pan_mod: int = ...
    parent: Union[int, str] = ...
    password: bool = ...
    payload_type: str = ...
    picker_mode: int = ...
    pmax: Union[list[float], tuple[float, ...]] = ...
    pmin: Union[list[float], tuple[float, ...]] = ...
    points: list[list[float]] = ...
    policy: int = ...
    popup: bool = ...
    popup_align_left: bool = ...
    pos: Union[list[float], tuple[float, ...]] = ...
    positive: Union[list[float], tuple[float, ...]] = ...
    precise_widths: bool = ...
    prefer_sort_ascending: bool = ...
    prefer_sort_descending: bool = ...
    qualitative: bool = ...
    query: bool = ...
    query_button: int = ...
    query_mod: int = ...
    query_toggle_mod: int = ...
    radius: float = ...
    readonly: bool = ...
    reorderable: bool = ...
    resizable: bool = ...
    rounding: float = ...
    row_background: bool = ...
    row_ratios: Union[list[float], tuple[float, ...]] = ...
    rows: int = ...
    scale: float = ...
    scale_max: float = ...
    scale_min: float = ...
    scientific: bool = ...
    scrollX: bool = ...
    scrollY: bool = ...
    secondary_color: Union[list[int], tuple[int, ...]] = ...
    segments: int = ...
    selectable: bool = ...
    shape: int = ...
    shortcut: str = ...
    show: bool = ...
    show_label: bool = ...
    size: float = ...
    small: bool = ...
    sort_multi: bool = ...
    sort_tristate: bool = ...
    sortable: bool = ...
    source: Union[int, str] = ...
    span_columns: bool = ...
    speed: float = ...
    step: int = ...
    step_fast: int = ...
    style: int = ...
    tab_input: bool = ...
    tag: Union[int, str] = ...
    target: int = ...
    text: str = ...
    texture_tag: Union[int, str] = ...
    thickness: float = ...
    threshold: float = ...
    time: bool = ...
    tint_color: Union[list[int], tuple[int, ...]] = ...
    tooltip: bool = ...
    track_offset: float = ...
    tracked: bool = ...
    trailing: bool = ...
    uppercase: bool = ...
    use_internal_label: bool = ...
    user_data: Any = ...
    uv_max: Union[list[float], tuple[float, ...]] = ...
    uv_min: Union[list[float], tuple[float, ...]] = ...
    value: Any = ...
    values: Union[list[float], tuple[float, ...]] = ...
    vertical: bool = ...
    vertical_mod: int = ...
    weight: int = ...
    width: int = ...
    width_fixed: bool = ...
    width_stretch: bool = ...
    wrap: int = ...
    x: Union[list[float], tuple[float, ...]] = ...
    x_offset: int = ...
    xbins: int = ...
    xmax_range: float = ...
    xmin_range: float = ...
    xoffset: float = ...
    y: float = ...
    y1: Union[list[float], tuple[float, ...]] = ...
    y2: Any = ...
    y_offset: int = ...
    ybins: int = ...
    ymax_range: float = ...
    ymin_range: float = ...
